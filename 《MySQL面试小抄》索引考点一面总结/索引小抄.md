《MySQL面试小抄》索引考点一面总结

我是肥哥，一名不专业的面试官！

我是囧囧，一名囧囧表示：面试最怕的就是问的知识点太笼统，自己无法快速定位到关键问题点

本期主要面试考点

```
面试官考点之谈谈你对索引的理解？
```

```
面试官考点之解释一下计算机层面索引快的原因？
```

```
面试官考点之为什么不使用哈希结构作为索引结构？
```

```
面试官考点之为什么不使用二叉树作为索引结构？
```

```
面试官考点之为什么不适用B-Tree，而是B+Tree？
```

```
面试官考点之是否应该给表尽可能建立多的索引列？
```

面试官考点之谈谈你对索引的理解？

谈到索引，最先联想到的大概就是字典目录，根据MySQL官方定义，索引是用来帮助MySQL高效获取数据的一种数据结构。本质上：索引是一种有序的快速查找的数据结构，用来快速高效的查找数据。

简单来说，可以类比字典目录，火车车次表。

面试官考点之解释一下计算机层面索引快的原因？

计算机从磁盘获取数据，加载到内存期间，一般都要经历3个常规的耗时过程：

1、寻道（时间）：确定要读的数据在哪个磁道耗费的时间
2、旋转延迟（时间）：确定要读的数据在磁道上的哪个扇区耗费的时间
3、数据传输（时间）：数据加载到内存耗费的时间

每次加载数据，我们称其为一次磁盘IO，每一次IO操作耗费时间 = 寻道 + 旋转延迟 + 数据传输（时间短暂，可以忽略不计）。

事实上实际加载数据到内存的时间非常短暂，一次IO操作主要的耗时来自寻道和旋转延迟。

总体来说，一般一次IO操作，耗时大概只有几ms。假如是4ms，虽然看起来很短暂，但是数据库百万级别的数据加载一遍，就需要4000s，对于一个系统来说，简直是毁灭级别的。

我们需要的就是减少磁盘IO的次数，这也是使用索引的意义所在！！！索引能够保证在亿级别的数据，只需要2~4次磁盘IO，这无疑是个福音！

面试官考点之为什么不使用哈希结构作为索引结构？

一般正常的业务场景中，通常查询多数是范围查询 类似：

```mysql
select id, name, age from sys_user where age between 18 and 28;
```

哈希结构作为索引，那么存储引擎就会为每一行表记录计算出哈希值，哈希索引存储的就是HASH码，HASH码直接随机生成，并没有规律，没有规律的HASH码，导致数据随机分布存储，这就导致即使是两个很相近的行记录，极大可能也会被分配到不同的桶（磁盘块）中。

最坏的情况下每查找一条记录，都要进行一次磁盘IO （可怕）。

优点，哈希结构这样key-val 键值对的形式对于精确查找非常敏感，对全值匹配很友好，所以单条记录查询效率非常高，时间复杂度为 1，但是我们日常业务来说，最常用的还是范围搜索，所以不哈希结构适合。

记住一点即可：**Hash索引适合精确查找，全值匹配，不适合范围查找。**

MySQL目前有Memory引擎和NDB引擎支持Hash索引。



面试官考点之为什么不使用二叉树作为索引结构？

首先观察一下二叉树结构



![二叉树](C:\Users\zhiyuan\Desktop\《MySQL面试小抄》索引考点一面总结\二叉树.png)

假设二叉树结构作为索引，理想情况下是一颗完全二叉树，那么具有n个节点的完全二叉树深为log2x+1

（其中x表示不大于n的最大整数）

如果一个数据在二叉树结构的100层，那么为了查找到此数据，需要进行100次磁盘IO







二叉树最多有两个子节点，这种结构导致树的高度会很高，增加IO次数，特殊情况下可能化为链表结构，相当于全表扫描，全量磁盘IO。









































![索引小抄](C:\Users\zhiyuan\Desktop\《MySQL面试小抄》索引考点一面总结\索引小抄.png)





