
a、你好面试官，我是应聘员囧囧，我应聘的是数据库开发工程师，我是xxx(...3分钟介绍)

b、你好，我是面试官大肥

a MySQL服务器高负载情况下，我们需要采取一种措施给服务器减轻压力

a 一个复杂的查询是非常消耗性能的

a 其中磁盘IO又占据主要资源

缓存是对系统性能优化的一种重要手段

今天我们叫聊聊MySQL的查询缓存

你先简单介绍一下什么是查询缓存？

b 
查询缓存机制设计是为了从根本上减少磁盘IO次数

MySQL开启缓存后，将SQL和结果集以键值对KV的形式存储在内存

当相同的SQL再次进入，MySQL会直接返回缓存在内存中的结果集

不再需要经过一系列复杂的解析优化和磁盘IO过程

a 如何命中缓存？

select id from user;

select id FROM user;

上面语句能命中缓存吗？

b 不能

MySQL缓存命中机制有严格苛刻的要求

在判断命中前，MySQL不会对SQL做任何的解析处理

SQL上的任何字符的不同，如大小写、空格、注释等都会导致缓存不命中

a 什么场景下SQL和结果集不会被缓存？或者说缓存规则是什么？

b 第一种情况：查询语句中包含不确定数据

例如查询语句中包含不确定函数：NOW()、CURRENT_DATE()等。

因为每次执行这类带了不确定数据的查询所返回结果可能是不同的。

第二种情况：超过了query_cache_limit预设阈值

a 什么场景下会导致MySQL缓存失效？

b 任何对于表结构或者表数据的更新操作，

一定会造成查询缓存中的数据失效，

同时查询缓存值的相关条目也会被清空

MySQL判定有更新操作，就会设置所有的查询缓存失效

a 嗯嗯

这样吧，跟我简单讲查询缓存是如何进行内存管理的？

b 

MySQL服务启动，缓存机制会在内存中开辟一块内存，

其中会划分出一块区域专用来管理维护缓存数据的元数据

例如空间内存、数据表和查询结果的映射，SQL和查询结果的映射

MySQL缓存机制将剩余的空闲空间分为一个个小数据块，

用来存储缓存结果

每个小块中存储自身的类型、

大小和查询结果数据，

还有指向前后内存块的指针。

a 一条SQL查询缓存分配内存过程是怎么样的？

a MySQL是一次性分配所有的内存空间吗？

b 不是，因为无法预知查询结果，

所以mysql无法为每个查询结果精确分配大小恰好匹配的缓存空间，

MySQL缓存机制采用的是边查边存，

动态申请缓存内存

b 当有查询结果需要缓存的时候，

MySQL缓存机制会在SQL查询开始（还未得到结果）时

就去申请一块内存空间（小数据块），

在不断查询中，

如果发现不够则继续申请，

如果存储完时有空余则释放多余的内存空间

如果余下的需要回收的空间很小，

小于query_cache_min_res_unit，

不能再次被使用，可能会造成内存碎片

a 缓存中的内存碎片无法避免

那么有什么办法优化吗？

b 
没有什么办法能够完全避免碎片，

但是选择合适的query_cache_min_res_unit

可以减少由碎片导致的内存空间浪费

a 我怎么去确定这个值呢？

a 
值太小，则浪费的空间更少，但是会导致频繁的内存块申请操作

如果设置得太大，那么碎片会很多

调整合适的值其实是在平衡内存浪费和CPU消耗

那么我如何确定这个平衡值？

b

可以通过内存实际消耗，计算单个查询的平均缓存大小

（query_cache_size - Qcache_free_memory）/ Qcache_queries_in_cahce

通过查看闲置内存块数量（Qcahce_free_blocks）来观察碎片。

a 如果产生的碎片过多，通过什么方法可以整理碎片？

b 
通过FLUSH_QUERY_CAHCE清理碎片

这个命令将所有的查询缓存重新排序，

并将所有的空闲空间都聚焦到查询缓存的一块区域上。

a MySQL4.0提出了查询缓存，它设计出来是为了加速那些查询场景？

b 
1、并发性和查询QPS不高
2、被访问的底层数据本质上是静态或半静态的
3、查询密集型应用，更新频率非常低而只读查询频率非常高的场景

a MySQL5.6中默认禁用，8.0以后完全移除，

造成这个改变的原因是什么？

b 

理想情况下，上述查询场景非常适合使用查询缓存

但是实际的业务系统都是有CRUD操作的

在MySQL里QC是由一个全局锁在控制，

每次更新QC的内存块都需要进行锁定，

数据更新频繁，就会不断的失效缓存操作

同时缓存失效会造成大量的查询缓存碎片化

更加还会导致服务器的负载升高，影响数据库的稳定性


a 生产要不要开启MySQL缓存？


b 

建议不开启

根据MySQL官方的测试，

如果对一个表执行简单的查询，但每次查询都不一样的话，

打开QC后，性能反而下降了13%左右

当然实际业务中，不会都是这种不同的请求，

因此实际影响应该比这个小一些。

MySQL查询缓存的目的是为了提升查询性能，

但它本身也是有性能开销的。

需要在合适的业务场景下（读写压力模型）使用，

不合适的业务场景不但不能提升查询性能，

查询缓存反而会变成MySQL的瓶颈。