1、like通配符，左侧开放情况下，全表扫描
2、or条件筛选，可能会导致索引失效
3、where中对索引列使用mysql的内置函数，一定失效
4、where中对索引列进行运算（如，+、-、*、/），一定失效
5、类型不一致，隐式的类型转换，导致的索引失效
6、where语句中索引列使用了负向查询，可能会导致索引失效。负向查询包括：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等。
7、索引字段可以为null，使用is null或is not null时，可能会导致索引失效
8、隐式字符编码转换导致的索引失效
9、联合索引中，where中索引列违背最左匹配原则，一定会导致索引失效
10、MySQL优化器的最终选择，不走索引



准备数据表，同时建立普通索引 idx_user_name

```mysql
CREATE TABLE `t_user` (
  `id` int(11) NOT NULL,
  `user_name` varchar(32) CHARACTER DEFAULT NULL COMMENT '用户名',
  `address` varchar(255) CHARACTER DEFAULT NULL COMMENT '地址',
  `create_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

插入1万条数据（注意：数据多些，mysql不走索引情况之一是**数据量非常少**，MySQL查询优化器认为全表扫描比使用索引更快，导致索引失效，explain检查是否使用索引时，发现无法走索引）

```mysql
-- 创建存储过程，插入10000用户信息
CREATE PROCEDURE user_insert()
-- 定义存储过程开始
BEGIN
	-- 定义变量 i ，int 类型，默认值为 1
	DECLARE i INT DEFAULT 1;
	
	WHILE i <= 10000
		-- 定义循环内执行命令
		DO INSERT INTO t_user(id, user_name, address, create_time) VALUES(i, CONCAT('mayun', i), CONCAT('浙江杭州', i), now());
		SET i=i+1;
	END WHILE;
	
	COMMIT;
END;
-- 定义存储过程结束


-- 调用存储工程
CALL user_insert();
```



### OR索引失效验证

![or查询](C:\Users\zhiyuan\Desktop\daily-notes\《MySQL面试小抄》索引考点二面总结\or查询.png)

> OR 连接的是同一个字段，相同走索引

```
explain select * from t_user where user_name = 'mayun10' or user_name = 'mayun1000'
```

<img src="C:\Users\zhiyuan\Desktop\daily-notes\《MySQL面试小抄》索引考点二面总结\or查询走索引情况.png" alt="or查询走索引情况" style="zoom:100%;" />



> OR 连接的是两个不同字段，不同索引失效

```
explain select * from t_user where user_name = 'mayun10' or address = '浙江杭州12'
```

![or查询索引失效情况](C:\Users\zhiyuan\Desktop\daily-notes\《MySQL面试小抄》索引考点二面总结\or查询索引失效情况.png)

> 给address列增加索引

```
alter table t_user add index idx_address (address)
```



> OR 连接的是两个不同字段，如果两个字段皆有索引，走索引
>



![or查询走索引情况-两边字段有索引](C:\Users\zhiyuan\Desktop\daily-notes\《MySQL面试小抄》索引失效场景验证\or查询走索引情况-两边字段有索引.png)



