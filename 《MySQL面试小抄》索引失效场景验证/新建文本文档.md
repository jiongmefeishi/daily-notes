准备数据表，同时建立普通索引 idx_user_name

```mysql
CREATE TABLE `t_user` (
  `id` int(11) NOT NULL,
  `user_name` varchar(32) CHARACTER DEFAULT NULL COMMENT '用户名',
  `address` varchar(255) CHARACTER DEFAULT NULL COMMENT '地址',
  `create_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`),
  KEY `idx_user_name` (`user_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

插入1万条数据（注意：数据多些，mysql不走索引情况之一是**数据量非常少**，MySQL查询优化器认为全表扫描比使用索引更快，导致索引失效，explain检查是否使用索引时，发现无法走索引）

```mysql
-- 创建存储过程，插入10000用户信息
CREATE PROCEDURE user_insert()
-- 定义存储过程开始
BEGIN
	-- 定义变量 i ，int 类型，默认值为 1
	DECLARE i INT DEFAULT 1;
	
	WHILE i <= 10000
		-- 定义循环内执行命令
		DO INSERT INTO t_user(id, user_name, address, create_time) VALUES(i, CONCAT('mayun', i), CONCAT('浙江杭州', i), now());
		SET i=i+1;
	END WHILE;
	
	COMMIT;
END;
-- 定义存储过程结束


-- 调用存储工程
CALL user_insert();
```



1、情况一 or

```mysql
explain select * from t_user where user_name = 'mayun10' or user_name = 'mayun1000';

explain select * from t_user where user_name = 'mayun10' or address = '浙江杭州12';

explain select * from t_user where address = '浙江杭州12' or user_name = 'mayun10';
```





explain select * from t_user where address = '浙江杭州12' or user_name = 'mayun10';

假设address有索引，依然不走索引



因此才有建议说，尽量避免使用or语句，可以根据情况尽量使用union all或者in来代替，这两个语句的执行效率也比or好些。



下面这条语句其实是命中索引的（据说是新版本的MySQL才可以，如果你使用的是老版本的MySQL，可以使用explain验证下）。

```
select` `* ``from` ````user``` ``where` `user_id = 1 ``or` `user_id = 2;
```

但是这条语句是无法命中索引的。

```
select` `* ``from` ````user``` ``where` `user_id = 1 ``or` `age = 20;
```

假设age列也有索引的话，依然是无法命中索引的。

```
select` `* ``from` ````user``` ``where` `user_id = 1 ``or` `age = 20;
```





**2. where语句中索引列使用了负向查询，可能会导致索引失效**

负向查询包括：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等。

某“军规”中说，使用负向查询一定会索引失效，笔者查了些文章，有网友对这点进行了反驳并举证。

其实负向查询并不绝对会索引失效，这要看MySQL优化器的判断，全表扫描或者走索引哪个成本低了。

**3. 索引字段可以为null，使用is null或is not null时，可能会导致索引失效
**

其实单个索引字段，使用is null或is not null时，是可以命中索引的，但网友在举证时说两个不同索引字段用or连接时，索引就失效了，笔者认为确实索引失效，但这个锅应该由or来背，属于第一种场景~~

假设USER表中的user_id列有索引且允许null，age列有索引且允许null。





- null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化。
- null 这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多。
- null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标识。
- 对null 的处理时候，只能采用is null或is not null，而不能采用=、in、<、<>、!=、not in这些操作符号。如：where name!='shenjian'，如果存在name为null值的记录，查询结果就不会包含name为null值的记录。





[MySQL中索引失效的常见场景与规避方法_Mysql_脚本之家 (jb51.net)](https://www.jb51.net/article/176633.htm)

**4. 在索引列上使用内置函数，一定会导致索引失效**

比如下面语句中索引列login_time上使用了函数，会索引失效：

```
select` `* ``from` ````user``` ``where` `DATE_ADD(login_time, INTERVAL 1 ``DAY``) = 7;
```

优化建议，尽量在应用程序中进行计算和转换。

其实还有网友提到的两种索引失效场景，应该都归于索引列使用了函数。

**4.1 隐式类型转换导致的索引失效**

比如下面语句中索引列user_id为varchar类型，不会命中索引：

```
select` `* ``from` ````user``` ``where` `user_id = 12;
```

这是因为MySQL做了隐式类型转换，调用函数将user_id做了转换。

```
select` `* ``from` ````user``` ``where` `CAST``(user_id ``AS` `signed ``int``) = 12;
```





































