需要验证的问题
1、like通配符，左侧开放情况下，全表扫描
2、or条件筛选，可能会导致索引失效
3、where中对索引列使用mysql的内置函数，一定失效
4、where中对索引列进行运算（如，+、-、*、/），一定失效
5、类型不一致，隐式的类型转换，导致的索引失效
6、where语句中索引列使用了负向查询，可能会导致索引失效。负向查询包括：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等，其中：!< !> SQLServer语法。
7、索引字段可以为null，使用is null或is not null时，可能会导致索引失效
8、隐式字符编码转换导致的索引失效
9、联合索引中，where中索引列违背最左匹配原则，一定会导致索引失效
10、MySQL优化器的最终选择，不走索引



a、你好面试官，我是应聘员囧囧，我应聘的是数据库开发工程师，我是xxx(...3分钟介绍)

b、你好，我是面试官大肥

b 囧囧你好！

b 我们都知道作为数据库开发人员，索引是必知必会的知识！

b、索引加速查询，我们会创建的同时也要关注索引在查询中是否生效

b 今天我们就简单聊聊索引失效问题吧？

b select * from t_user where user_name like '%mayun100%';

b 根据这条查询，你简单分析一下！

a like 通配符特性是可以左右开闭匹配查询

当左边开放使用 % 或者 _ 匹配的时候都不会走索引，会进行全表扫描


b 为什么左开情况下会索引失效?请介绍一下原理！

a 我们知道建立索引后，MySQL会建立一棵有序的B+Tree

因为索引树时有序的，在进行索引列查询匹配时候是从左到又进行匹配的

但是 % 和 _ 匹配时表示左边匹配值是不确定的

不确定，怎么比较？

只能一个一个的比较，那就相当于，全匹配了

全匹配在优化器看来，与其走索引树查询，在进行不断的回表操作，还不如直接进行全表扫描。

b 嗯，挺好的

b 好多人说where条件中使用 or ，那么查询索引失效，是否正确？

a or是可能会导致索引失效，并非一定

这里涉及到MySQL index merge 技术。

MySQL5.0之前，一个表一次只能使用一个索引，无法同时使用多个索引分别进行条件扫描。

但是从5.1开始，引入了 index merge 优化技术，对同一个表可以使用多个索引分别进行条件扫描。

然后将它们各自的结果进行合并(intersect/union)。

or走索引的情况两种

第一种 or两边连接的是同一个索引字段

第二种 or两边连接的是两个索引字段，即两个字段分别都建立索引

b 是的，想当初我们之前优化or 查询时都是用UNION替换OR

后来MySQL5.1后改版优化这个问题，增加了index merage

同一个表的多个索引的范围扫描可以对结果进行合并

合并方式分为三种：union, intersection, 以及它们的组合(先内部intersect然后在外面union)。

b 





3、where中对索引列使用mysql的内置函数，一定失效
4、where中对索引列进行运算（如，+、-、*、/），一定失效
5、类型不一致，隐式的类型转换，导致的索引失效




6、where语句中索引列使用了负向查询，可能会导致索引失效。负向查询包括：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等，其中：!< !> SQLServer语法。
7、索引字段可以为null，使用is null或is not null时，可能会导致索引失效
8、隐式字符编码转换导致的索引失效
9、联合索引中，where中索引列违背最左匹配原则，一定会导致索引失效
10、MySQL优化器的最终选择，不走索引













































