需要验证的问题
1、like通配符，左侧开放情况下，全表扫描
2、or条件筛选，可能会导致索引失效
3、where中对索引列使用mysql的内置函数，一定失效
4、where中对索引列进行运算（如，+、-、*、/），一定失效
5、类型不一致，隐式的类型转换，导致的索引失效
6、where语句中索引列使用了负向查询，可能会导致索引失效。负向查询包括：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等，其中：!< !> SQLServer语法。
7、索引字段可以为null，使用is null或is not null时，可能会导致索引失效
8、隐式字符编码转换导致的索引失效
9、联合索引中，where中索引列违背最左匹配原则，一定会导致索引失效
10、MySQL优化器的最终选择，不走索引



a、你好面试官，我是应聘员囧囧，我应聘的是数据库开发工程师，我是xxx(...3分钟介绍)

b、你好，我是面试官大肥

b 囧囧你好！

b 我们都知道作为数据库开发人员，索引是必知必会的知识！

b、索引加速查询，我们会创建的同时也要关注索引在查询中是否生效

b 今天我们就简单聊聊索引失效问题吧？

b select * from t_user where user_name like '%mayun100%';

b 根据这条查询，你简单分析一下！

a like 通配符特性是可以左右开闭匹配查询

当左边开放使用 % 或者 _ 匹配的时候都不会走索引，会进行全表扫描


b 为什么左开情况下会索引失效?请介绍一下原理！

a 我们知道建立索引后，MySQL会建立一棵有序的B+Tree

因为索引树时有序的，在进行索引列查询匹配时候是从左到又进行匹配的

但是 % 和 _ 匹配时表示左边匹配值是不确定的

不确定，怎么比较？

只能一个一个的比较，那就相当于，全匹配了

全匹配在优化器看来，与其走索引树查询，在进行不断的回表操作，还不如直接进行全表扫描。

b 嗯，挺好的

b 好多人说where条件中使用 or ，那么查询索引失效，是否正确？

a or是可能会导致索引失效，并非一定

这里涉及到MySQL index merge 技术。

MySQL5.0之前，一个表一次只能使用一个索引，无法同时使用多个索引分别进行条件扫描。

但是从5.1开始，引入了 index merge 优化技术，对同一个表可以使用多个索引分别进行条件扫描。

然后将它们各自的结果进行合并(intersect/union)。

or走索引的情况两种

第一种 or两边连接的是同一个索引字段

第二种 or两边连接的是两个索引字段，即两个字段分别都建立索引

b 是的，想当初我们之前优化or 查询时都是用UNION替换OR

后来MySQL5.1后改版优化这个问题，增加了index merage

同一个表的多个索引的范围扫描可以对结果进行合并

合并方式分为三种：union, intersection, 以及它们的组合(先内部intersect然后在外面union)。

b 联合索引失效场景了解吗？简单说明一下！

联合索引依据最左匹配原则建立索引树，在查询时依据联合索引顺序依次匹配索引值

查询时如果违背最左匹配原则，将导致索引失效

假设建立索引 idx_a_b_c，相当于建立了 (a), (a,b), (a,b,c)三个索引

查询时如果没有 a 字段筛选，那么索引将失效

b 举栗子，走索引情况

a 
select * from test where a=1 
select * from test where a=1 and b=2 
select * from test where a=1 and b=2 and c=3

b 索引失效呢？

select * from test where b=2 and c=3

联合索引如果要走索引，查询条件中必须要包含第一个索引，否则索引失效

b 那么 select * from test where b=1 and a=1呢？

a 满足最左前缀，走索引

b select * from test where m='222' and a=1

包含最左索引 a ，索引有效

你解释一下这两条查询走索引的原因是什么？

最左前缀指的是查询时匹配联合索引创建的顺序

在书写时不需要严格按照联合索引创建的顺序，MySQL优化器会自动调整，所以上面两条查询索引有效


b 还有那些索引失效场景？

a 
where中对索引列使用mysql的内置函数，一定失效
where中对索引列进行运算（如，+、-、*、/），一定失效
字段类型不一致，隐式的类型转换，索引失效
隐式字符编码转换导致的索引失效
where语句中索引列使用了负向查询，可能会导致索引失效。负向查询包括：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等，其中：!< !> SQLServer语法。
索引字段可以为null，使用is null或is not null时，可能会导致索引失效


b 如果我规避了上面这些情况，那么我建立的索引一定会生效吗？

假设我建立了 idx_age

select * from user where age = 50

MySQL查询索引失效的情况有很多

即使上面情况都规避，但是在经过了优化器的确定查询方案的时候，依然可能索引失效

优化器会考虑查询成本，来确认它认为的最佳方案来执行查询

当数据量较少，或者需要访问行很多的时候

优化器会认为走索引树来进行回表，还不如直接进行全表扫描的时候

将会抛弃走索引树

假设10万用户

age > 99 的有几百人时，会走idx_age

age > 59 的有9万人时，很大的可能会进行全表扫描



b 差不多索引失效的一般场景就这些了，我们要做的就是尽可能的规避一些情况

有目的性的建立，使用，优化索引，从而达到业务需要

b 小伙子，棒棒哒

