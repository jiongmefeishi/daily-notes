题目：囧囧的MySQL索引二面问答小抄



a、你好面试官，我是应聘员囧囧，我应聘的是数据库开发工程师，我是xxx(...3分钟介绍)

b、你好，我是面试官大肥

b、一面咱们聊了一些MySQL基础知识，本面继续深入一下。

b 上期我们说到，索引不是越多越好，你提到了时间空间消耗，那你今天简述一下索引维护过程？

a B+树为了维护索引有序性，在插入删除的时候需要做必要的维护，必要时候可能涉及到页分裂，页合并过程！

a 假设每个叶子节点（数据页）只能存储3条索引和数据记录，如图

情况1、新增行记录，ID=3，此时【数据页1】未满，只需要在data2后新增ID=3的行记录，B+树整体结构不需要进行调整

情况2、新增行记录，ID=8，此时【数据页2】已满，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。

有分裂就有合并。

当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

【数据页2】删除了ID=7,ID=8的行记录，此时【数据页2】【数据页3】利用率很低，将进行页合并。


b、挺好，页分裂过程消耗性能，同事空间利用率也降低了



b、 给你一张用户表，其中id为主键，age为普通索引

CREATE TABLE `user` (
  `id` int(11) PRIMARY KEY,
  `name` varchar(255) DEFAULT NULL,
  `age` int(11) DEFAULT NULL
  KEY `idx_age` (`age`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;


b、select * from user where age=22 简述一下B+树索引搜索过程？

假设要查询的记录 id=5,name="张三",age=22

a 

MySQL为每个索引分别维护了一棵B+Tree索引树，

主键索引非叶子节点维护了索引键，叶子节点存储行数据；

非主键索引也称为二级索引，非叶子节点存储主键

搜索条件 age=22，可走idx_age索引，首先加载idx_age索引树，找到age=22的记录，取得id=5

回表搜索，加载主键索引树，找到id=22的记录，取的整行数据

b、什么是回表？

idx_age二级索引树找到主键id后，回到id主键索引搜索的过程,就称为回表。

b、所有非主键索引搜索，都需要进行回表搜索吗？

a、不是，在上面提到的例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。

如果在查询的数据列里面，直接从索引列就能取到想要的结果，就不需要再回表去查，也称之为索引覆盖！

b、索引覆盖，嗯，那请你修改一下上述栗子，满足索引覆盖条件？

a 索引覆盖的优点


1、可以避免对Innodb主键索引的二次查询
2、可以避免MyISAM表进行系统调用
3、可以优化缓存,减少磁盘IO操作


a、 select id, age from user where age=22

查询的信息，id，age都可以直接在idx_age 索引树中获取，不需要回表搜索

a 由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用
的性能优化手段。

b、索引是一把双刃剑，提供快速排序搜索的同时，索引字段的维护也是要付出相应的代价的。

因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务DBA，或者称为业务数据架构师的工作。

b 你创建的索引，到底有没有生效，或者说你们的SQL语句有没有使用索引查询你排查过吗？

a 慢SQL的场景才会去排查，explain查看索引是否失效

b 问你一个最常见的查询场景，建立idx_name索引

select name from user where name like '%马%';

b 这条查询是否走索引？

a 不走idx_name 索引，like通配符全开区间情况下，加载数据表，进行全表扫描，

在左边闭合情况下会走索引，like '马%'

b 嗯，很好

b 这样吧，你大致总结一下，有哪些情况下，可能会面临索引失效的问题？

a 

1、like通配符，左侧开放情况下，全表扫描
2、or条件筛选，可能会导致索引失效
3、where中对索引列使用mysql的内置函数，一定失效
4、where中对索引列进行运算（如，+、-、*、/），一定失效
5、类型不一致，隐式的类型转换，导致的索引失效
6、where语句中索引列使用了负向查询，可能会导致索引失效 负向查询包括：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等。
7、索引字段可以为null，使用is null或is not null时，可能会导致索引失效
8、隐式字符编码转换导致的索引失效
9、联合索引中，where中索引列违背最左匹配原则，一定会导致索引失效
10、MySQL优化器的最终选择，不走索引


b 概况的很全面，我简单询问一个，or走索引和索引失效分别是什么场景？

a or左右两边的查询列是否命中相同的索引列，OR连接的是同一个字段，相同走索引，不同，索引失效！

a（插播，下一期：《MySQL面试小抄》几种索引失效场景验证）以实际数据测验索引失效场景，尽请关注：囧么肥事，面试小抄系列。

b 小伙子，我看好你，有钱途！

b 哪些情况下需要创建索引？

a 我简单说一下了解到的常见需要创建索引的场景


1.主键自动建立唯一索引

2.频繁查询的字段

3.JOIN 关联查询，作为外键关系的列建立索引

4.单键/组合索引的选择问题，高并发下倾向创建组合索引，创建时遵循最左前缀匹配原则

5.ORDER BY 查询中排序的字段，排序字段通过索引访问大幅提高排序速度

6.GROUP BY 需要分组字段或查询中统计字段

b 嗯，不得不说，基础还是很扎实的

b 最后在问你一个问题

b 关于索引下推了解吗？

a 知道一些，大概是MySQL5.6版本开始提出的概念

a 下面是我建立的联合索引 idx_age_weight

a select * from user where age = 11 and weight = 98


5.6之前搜索过程是

在idx_age_weight 索引树中匹配出所有的 age = 11 索引，拿到主键id，回表去一条条再比对weight字段

如下图，需要进行3次回表搜索操作


图一：5.6之前


5.6后的搜索过程是
在idx_age_weight 索引树中匹配出所有的 age = 11 索引，顺便对weight字段进行判断，过滤掉weight = 100的记录，然后再进行回表搜索，如下图，只需要进行2次回表搜索操作

图二：5.6开始



































