### 《力扣算法训练提升》图解数组篇-打卡数组统计-【435】最小移动次数使数组元素相等

![打卡]

### 数组的基本特性

数组是最简单的数据结构。

数组是用来存储一系列**相同类型**数据，数据**连续存储**，一次性分配内存。

数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。

### 囧么肥事今日打卡题目

**力扣【435.最小移动次数使数组元素相等】**

给定一个长度为 *n* 的 **非空** 整数数组，每次操作将会使 *n* - 1 个元素增加 1。找出让数组所有元素相等的最小操作次数。

**具体描述**

![算法描述]

### 解题讨论

![讨论分析]



**跨步计算示例**

![示例]



**讨论归纳**


```
第一步：排序
第二步：遍历数组，计算跨步，即最大值和最小值差值
第三步：累加跨步
```

![1-跨步]

### 动画模拟

![跨步]

**示例一：跨步计算**

```
// 排序后计算跨步，最大值到最小值跨步累加就是操作次数
public static int minMoves(int[] nums) {
    // 4 1 9 3

    //  1  3  4  9      排序后
    //  9 11 12  9      跨步：8
    // 12 14 12 12      跨步：3
    // 14 14 14 14      跨步：2

    Arrays.sort(nums);
    int count = 0;
    int min = nums[0];
    int step = 0;
    for (int i = nums.length - 1; i > 0; i--) {
        // 计算跨步 = 最大最小差值
        step = nums[i] - min;
        // 累加跨步
        count += step;
        // 更新 nums[i - 1]
        nums[i - 1] = nums[i - 1] + count;
        // 更新最小数
        min += step;
    }
    return count;
}
```

**复杂度分析**

```
时间复杂度：O(nlog(n))。 排序需要 O(nlog(n)) 的时间。
空间复杂度：O(1)。需要常量级额外空间。
```

**示例二：计算相对跨步**

```
// 省略数组元素修改
// 计算相对跨步
public static int minMoves(int[] nums) {
    Arrays.sort(nums);
    int count = 0;
    for (int i = nums.length - 1; i > 0; i--) {
        count += nums[i] - nums[0];
    }
    return count;
}
```

**复杂度分析**

```
时间复杂度：O(nlog(n))。 排序需要 O(nlog(n)) 的时间。
空间复杂度：O(1)。需要常量级额外空间。
```

![勇敢牛牛]

### 短话长说

学算法先学什么？什么阶段该刷什么题？

关注我，日常打卡算法图解。

按照力扣题目类别结构化排序刷题，从低阶到高阶，图解算法(更新中...)，有兴趣的童鞋，欢迎一起从小白开始零基础刷力扣，共同进步！

![短话长说]

回复：678，获取已分类好的部分刷题顺序，后续内容会持续更新，感兴趣的小伙伴自由拿取！

另外，有关分类，求小伙伴们不要再问我最后一类的起名了，奇技淫巧是个褒义词，意思是指新奇的技艺和作品。



**力扣修炼体系题目，题目分类及推荐刷题顺序及题解**

**目前暂定划分为四个阶段：**

```
算法低阶入门篇--武者锻体

算法中级进阶篇--武皇炼心

算法高阶强化篇--武帝粹魂

算法奇技淫巧篇--战斗秘典

以上分类原谅我有个修仙梦...
```

**缺漏内容，正在努力整理中...**









简介

力扣算法图解数组篇-打卡数组统计
【435】最小移动次数使数组元素相等
