https://juejin.cn/post/6850037271233331208#heading-6

1、文件存储结构
2、不同引擎锁粒度
3、事务
4、缓存
5、表空间 -----> MyISAM 小 InnoDB 大， ---> 疑惑
6、元数据存储文件 .frm
7、物理存储文件  
	MyISAM .MYD存储表数据 .MYI存储表索引  
	InnoDB .ibd 用于独享表空间存储方式，每一张表一个.ibd文件  .ibdata 用于共享表空间存储方式，所有表公用一个 .ibdata文件（或者多个，可以配置）
8、不同引擎，自增主键，MySQL重启后，最大id
9、CHAR,VARCHAR 实际分配空间
10、	谈谈你对索引的理解
11、索引创建，删除，修改语法
12、全文索引  ---> 疑惑
13、索引优势
14、索引劣势
15、从数据结构的角度划分索引类型
16、从物理存储角度划分索引类型
17、从逻辑角度划分索引类型
18、为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，为什么不用 Hash 索引
19、聚簇索引/非聚簇索引，MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？
20、使用索引查询一定能提高查询的性能吗？为什么?
21、B-Tree 和 B+Tree 树的区别
22、一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。
23、MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。
24、索引的最左匹配特性
25、为什么每个数据项，即索引字段要尽量的小？
26、MyISAM引擎的索引文件和数据文件是分离的
27、MyISAM主键索引与辅助索引的结构
28、InnoDB主键索引与辅助索引的结构
29、InnoDB的数据文件本身就是主键索引文件
30、Innodb的数据文件可以按照表来切分（只需要开启innodb_file_per_table），切分后存放在xxx.ibd中，默认不切分，存放在xxx.ibdata中。
31、回表
32、那为什么推荐使用整型自增主键而不是选择UUID？
33、InnoDB没有指明索引列
34、UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id > 5 && id < 20的条件查询语句。
35、为什么非主键索引结构叶子节点存储的是主键值？
36、Hash索引 MySQL目前有Memory引擎和NDB引擎支持Hash索引。
37、full-text全文索引
38、R-Tree空间索引 ？？？？？
39、为什么Mysql索引要用B+树不是B树？
40、面试官：为何不采用Hash方式？ 区间查询是无法直接通过索引查询的，哈希索引只适用于等值查询的场景，哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。
41、哪些情况需要创建索引
42、哪些情况不要创建索引
43、MySQL高效索引
44、查询中哪些情况不会使用索引？
45、索引优化




https://juejin.cn/post/6931901822231642125

1、系统中 SQL 的好坏，是能直接决定你系统的快慢的。但是在优化之前大家是否想过一个问题？那就是：我们优化的原则是什么？优化SQL的理论基础是什么？
2、索引的本质是一种排好序的数据结构
3、索引的分类 不同的种类很显然是为了应付不同的场合，那索引到底有那些种类呢？
4、Hash 索引，他的单条记录查询的效率很高，时间复杂度为1，Hash索引适合精确查找，但是范围查找不适合
5、为什么hash索引只能进行全职匹配的查询
6、磁盘的IO由树高决定，数据量越多，遍历次数越多，io次数越多
7、为什么使用B+Tree，而不是BTree？？？ Btree 每个节点不仅包含key值，还包含data值，每页的存储空间是有限的，如果 data 比较大，会导致每个节点的 key 存储的较少，当数据量较大的时候，同样会导致B树很深，从而增加了磁盘 IO 的次数，进而影响查询效率。
8、 B+ 树，他有以下特点：
	
	在 B+ 树中，所有数据记录节点都是按照键值的大小存放在同一层的叶子节点上，而非叶子结点只存储key的信息，这样可以大大增加每个节点的存储的key的数量，降低B+ 树的高度
	B+ 树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。
	B+ 树的层级更少：相较于 B 树 B+ 每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快
	B+ 树查询速度更稳定：B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
	B+ 树天然具备排序功能：B+ 树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
	B+ 树全节点遍历更快：B+ 树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。
9、聚簇索引是 MySQL 基于主键索引结构创建的
10、回表
11、索引页的分层



https://juejin.cn/post/6869532756498448392
1、磁盘io , 磁盘读取数据靠的是机械运动，每一次读取数据都要进行寻道，寻点，拷贝到内存
2、预读操作，把相邻的数据也加载到内存缓冲区
3、想要优化数据库查询，就要减少磁盘IO 操作，索引B+Treet
4、B+Tree相对于B-Tree有几点不同
5、弊端
6、10亿条数据，大概需要几次IO？？？
7、建立索引的时候应该遵循以下原则
8、B+树索引并不能找到一个给定键值的具体行，B+树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到缓冲池（buffer pool）中，在内存中通过二分查找法进行查找，得到需要的数据。




https://juejin.cn/post/6923788859712995336

面试官考点之索引是什么？ -- 用
面试官考点之索引类型 -- 用
面试官考点之为什么选择B+树作为索引结构
	为什么不使用哈希结构？
	为什么不使用二叉树呢？
	为什么不使用平衡二叉树呢？
	为什么不使用B树呢？
面试官考点之一次索引搜索过程
面试官考点之覆盖索引
面试官考点之索引失效场景
面试官考点之最左前缀
面试官考点之索引下推
面试官考点之大表添加索引








