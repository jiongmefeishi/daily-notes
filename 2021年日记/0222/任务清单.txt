1、本周计划 --> 3.8
	书写mysql相关文章内容
	1、收集mysql相关文章、书籍 （至少10篇，精简整合）
	2、阅读
	3、整合
		1、确定题目主体 -- > mysql 索引
		2、精简文章内容






a、你好面试官，我是应聘员囧囧，我应聘的是数据库开发工程师，我是xxx(...3分钟介绍)

b、你好，我是面试官大肥，我看简历上写了熟练使用mysql，那你能简单介绍一下一条MySQL语句整个执行过程吗？

b、例如 select * from tb_tmp where id=1 这条sql

a、
我先说一下MySQL查询工作的几个重要组成部分：
	1、客户端 
	2、连接器 
	3、查询缓存 
	4、分析器 
	5、优化器 
	6、执行器
	7、存储引擎

a、简单来说，除去客户端，MySQL可以大致划分为两层

a、连接器 
3、查询缓存 
4、分析器 
5、优化器 
6、执行器 

分属于Service层

a、service层涵盖了MySQL大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等）

a、所有的跨存储引擎的功能都在这一层实现

a、例如触发器，视图，存储过程等

b、请继续

a、
7、存储引擎 

分属于存储引擎层

a、存储引擎层负责数据的存储和提取，常见引擎MyISAM、InnoDB、Memory

a、MySQL采用的是插件式架构，可以轻易切换存储引擎

a、其中InnoDB引擎有自己的一套redolog日志模块

b、这个分层说的很好，继续

a、（...吞了吞没有的口水）
a、MySQL拿到一条查询请求后会先在查询缓存中检索是否执行过此查询
a、MySQL执行过的语句会以键值对 key-value 的形式缓存在内存中
a、key：查询语句hash值
a、value：查询结果集
a、新查询进来，检索缓存，如果命中key，直接返回结果集
a、如果没有命中，则进入分析器解析sql

b、嗯，那么查询缓存默认是开启还是关闭的？

a、默认是关闭状态

b、为什么默认是关闭的？究竟是开启好，还是关闭好？

a、我先分析一下查询缓存的优缺点

a、首先优点

a、将每次的查询结果集记录，当相同查询再次进入，可以直接返回之前保存的结果，对于处理重复请求，迅速高效，无需进行其他过程

a、好处是有，但是缺点也很明显

a、1、开启缓存，基于内存的操作，会消耗大量的内存空间

a、2、每次查询进入，都会检查是否命中缓存，额外开销

a、3、查询缓存的失效是非常频繁的，只要对一个表进行更新，插入，删除任意一次操作，那么关于本表的所有的查询缓存都会被清空

b、为什么都会被清空？

a、缓存在进行数据更新的时候，进行的是表级锁

a、更新结束后会清空所有的缓存

a、刚刚耗费性能存储下来的结果，一个更新全部都被清空

a、所以，常规情况下，还是选择关闭缓存

b、照你这么说，查询缓存岂不是没用？

a、不是，对一些特殊情况，查询缓存还是很有效的！ （emmm，自我挖坑）

b、哦？那好，你讲一下这个特殊情况？

a、（...心情复杂）
a、对于一些高频读，低频写的表非常适用，比如跟配置相关的表

a、最佳实践就是关闭，对于确定需要的，指定开启

a、对了，值得一提的是，mysql 8.0版本直接将查询缓存这块功能给删掉了

b、之前你说优点的时候，说了相同查询

b、select * from tmp 和 select * FROM tmp 查询几次？

a、两次，mysql的查询缓存十分严格，必须保证绝对相同，相对相同判定为两次不同的查询。

b、嗯，我没有疑问了，继续（..一脸冷漠）

a、无法命中缓存，sql 进入分析器进行词法分析，语法分析，生成解析树

a、第一步词法分析
	一条sql语句有多个字符串组成，
	提取关键词，如select，from
	提取查询的表，
	提取字段名，
	提取查询条件等

第二步语法分析
	判断输入的sql是否符合mysql的语法规范

b、请继续


a、接下来sql进入优化器

b、分析器说完了？（一脸坏笑的感觉）

b、你仔细想想，还有什么遗漏的地方？

a、这个我不知道

b、嗯，词法语法分析后生成解析树，还需要进入预处理器，对解析后的sql树进行再校验

b、语法分析是语法层面校验，预处理器检查查询表是否存在，别名是否有歧义等

a、原来是这样，受教了

b、请继续（...终于装了一X，满足脸）

a、sql经过分析器后就可以执行了，但是如何执行？怎么执行是最好的结果呢？这时候就需要查询优化器上场

a、查询优化器的任务是找到执行SQL查询的最佳计划

a、选择出它认为的最优的方案去执行（不一定最优）

b、你简单介绍其中做出计划的关键部分

a、优化器将解析叔优化成一个执行计划
	1、选择表扫或是走索引
	2、选择最合适的索引
	3、选择表关联顺序
	4、优化where子句
	5、决定 ORDER BY 和 GROUP BY 是否走索引
	6、尝试使用 inner join 替换 outer join
	7、简化子查询，决定结果缓存
	8、合并视图

a、优化器负责判断哪种方式更优，确定一个最佳执行计划，交给执行器执行

b、嗯，不错，讲的很好，全程我基本不用多说，你考虑的挺全面

b、此面结束，后面继续加油，期待你的加入！

a、谢谢


欢迎关注微信公众号：囧么肥事 jiongmefeishi




固定格式

1、图片增加3个水印： 公众号：囧么肥事
2、文章底部增加宣传：更多精彩内容，欢迎关注微信公众号：囧么肥事 jiongmefeishi
3、文章开头介绍
	大家好，我是肥哥！一个专注于打发时间的肥宅！

    






















