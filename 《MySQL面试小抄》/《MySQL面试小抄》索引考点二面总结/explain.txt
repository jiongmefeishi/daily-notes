1、面试官考点之覆盖索引
		刚刚你提到主键索引查询只会查一次，而非主键索引需要回表查询多次。（后来我才知道，原来这个过程叫做回表）是所有情况都是这样的吗？非主键索引一定会查询多次吗？

		覆盖索引？

		覆盖索引（coveringindex）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。
2、面试官考点之索引失效
3、面试官考点联合索引之最左前缀原则
4、面试官考点之索引下推
5、面试官考点之大表添加索引



Q： 那你们有用过联合索引吗？ 

A：用过呀，我们有对一些表中创建过联合索引

Q：那你们在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？ 



Q：那你知道在MySQL 5.6中，对索引做了哪些优化吗？ 

A：不好意思，这个我没有去了解过。（事后我查了一下，有一个比较重要的 ：Index Condition Pushdown Optimization）


Index Condition Pushdown（索引下推）

MySQL 5.6引入了索引下推优化，默认开启，使用SET optimizer_switch = 'index_condition_pushdown=off';可以将其关闭。官方文档中给的例子和解释如下：

people表中（zipcode，lastname，firstname）构成一个索引

SELECT * FROM people WHERE zipcode='95054' AND lastname LIKE '%etrunia%' AND address LIKE '%Main Street%';

如果没有使用索引下推技术，则MySQL会通过zipcode='95054'从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断数据是否符合条件。

如果使用了索引下推技术，则MYSQL首先会返回符合zipcode='95054'的索引，然后根据lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。




Q：你们创建的那么多索引，到底有没有生效，或者说你们的SQL语句有没有使用索引查询你们有统计过吗？

A：这个还没有统计过，除非遇到慢SQL的时候我们才会去排查 

Q：那排查的时候，有什么手段可以知道有没有走索引查询呢？

A：可以通过explain查看sql语句的执行计划，通过执行计划来分析索引使用情况

Q：那什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？ 

A：（大概记得和优化器有关，但是这个问题并没有回答好）

 

查询优化器？

一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。

在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。

这个成本最低的方案就是所谓的执行计划。优化过程大致如下：

1、根据搜索条件，找出所有可能使用的索引 

2、计算全表扫描的代价 

3、计算使用不同索引执行查询的代价 

4、对比各种执行方案的代价，找出成本最低的那一个

Q：哦，索引有关的知识我们暂时就问这么多吧。你们线上数据的事务隔离级别是什么呀？ 

A：(后面关于事务隔离级别的问题了，就不展开了)

基于主键索引和普通索引的查询有什么区别  考点回表



索引维护

这个过程称为页分裂
有分裂就有合并


你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无
绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该


自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条
新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂

而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。

从存储空间的角度来看

	假设你的表中确实有一个唯一字段，比如
	字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？


由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的
叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是
你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无
绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。8个字节。

主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。
所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。


有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样
的：
1. 只有一个索引；
2. 该索引必须是唯一索引。
你一定看出来了，这就是典型的KV场景。
由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。



覆盖索引

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用
的性能优化手段。

在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，
索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。


基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，是否有必要将身份
证号和名字建立联合索引？




索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑
了。这正是业务DBA，或者称为业务数据架构师的工作。



最左前缀原则

不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左
前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。


基于上面对最左前缀索引的说明，我们来讨论一个问题：在建立联合索引的时候，如何安排索
引内的字段顺序。


索引下推
上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能
要问，那些不符合最左前缀的部分，会怎么样呢？




在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。
而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索
引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。


在满足语句需求的情况下， 尽量少地访问资源是数据库设计的重要原则之一。我
们在使用数据库的时候，尤其是在设计表结构时，也要以减少资源消耗作为目标。






