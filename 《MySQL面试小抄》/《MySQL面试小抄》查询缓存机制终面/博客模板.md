# 《MySQL面试小抄》查询缓存机制终面

我是肥哥，一名不专业的面试官！

我是囧囧，一名积极找工作的小菜鸟！

> **囧囧表示：小白面试最怕的就是面试官问的知识点太笼统，自己无法快速定位到关键问题点！！！**

----



本期主要面试考点

```
面试官考点之简述一下什么是查询缓存机制？
```

```
面试官考点之查询如何命中缓存？
```

```
面试官考点之什么场景下SQL和结果集不会被缓存？
```

```
面试官考点之什么场景下会导致MySQL缓存失效？
```

```
面试官考点之查询缓存是如何进行内存管理的？
```

```
面试官考点之MySQL是一次性分配所有的内存空间吗？
```

```
面试官考点之缓存中的内存碎片无法避免，那么有什么办法优化吗？
```

```
面试官考点之MySQL4.0提出了查询缓存，它设计出来是为了加速哪些查询场景？
```

```
面试官考点之MySQL5.6中默认禁用，8.0以后完全移除，造成这个改变的原因是什么？
```

```
面试官考点之生产环境要不要开启MySQL缓存？
```



---

![qc1](https://img-blog.csdnimg.cn/img_convert/eebbb88837ad52345b80db9156876d66.png)

![qc2](https://img-blog.csdnimg.cn/img_convert/f50a2570770965316fa8165f47f3f054.png)



### 面试官考点之简述一下什么是查询缓存机制？

MySQL服务器高负载情况下，我们需要采取一种措施给服务器减轻压力，一个复杂的查询是非常消耗性能的，

其中磁盘IO又占据主要资源，缓存是对系统性能优化的一种重要手段。

>查询缓存机制设计是为了从根本上减少磁盘IO次数，MySQL开启缓存后，将SQL和结果集以键值对KV的形式存储在内存中。
>
>
>
>当相同的SQL再次进入，MySQL识别是相同查询喉，会直接返回缓存在内存中的结果集。
>
>避免再次进行一系列复杂的解析优化和磁盘IO过程。

### 面试官考点之查询如何命中缓存？

```
select id from user;

select id FROM user;
```

> 上面语句能命中缓存吗？

MySQL缓存命中机制有严格苛刻的要求，在判断命中前，MySQL不会对SQL做任何的解析处理。

```
SQL上的任何字符的不同，如大小写、空格、注释等都会导致缓存不命中
```

所以上面查询时无法命中缓存的。

### 面试官考点之什么场景下SQL和结果集不会被缓存？

或者说缓存规则是什么？

> 第一种情况：查询语句中包含不确定数据

```
例如查询语句中包含不确定函数：NOW()、CURRENT_DATE()等。

因为每次执行这类带了不确定数据的查询所返回结果可能是不同的。
```

> 第二种情况：超过了query_cache_limit预设阈值

```
超出了缓存内存能承受的范围，将放弃缓存！
```

### 面试官考点之什么场景下会导致MySQL缓存失效？

任何对于**表结构或者表数据的更新操作**，一定会造成查询缓存中的数据失效，同时查询缓存值的相关条目也会被清空。

MySQL判定有更新操作，就会设置所有的查询缓存失效。

### 面试官考点之查询缓存是如何进行内存管理的？

MySQL服务启动，缓存机制会在内存中开辟一块内存，

其中会`划分出一块区域`专用来管理维护缓存数据的**元数据**。

例如空间内存、数据表和查询结果的映射，SQL和查询结果的映射

MySQL缓存机制将剩余的空闲空间分为一个个小**数据块**，用来存储缓存结果。

```
每个小块中存储自身的类型，大小和查询结果数据，还有指向前后内存块的指针
```

### 面试官考点之MySQL是一次性分配所有的内存空间吗？

MySQL因为无法预知查询结果大小，所以无法为每个查询结果精确分配大小恰好匹配的缓存空间。

MySQL缓存机制采用的是边查边存，动态的去申请缓存内存。

> 一条SQL查询缓存分配内存过程是怎么样的？

当有查询结果需要缓存的时候，MySQL缓存机制会在SQL查询开始（还未得到结果）时就去申请一块内存空间（小数据块），在不断查询中，`如果发现不够则继续申请`，`如果存储完时有空余则释放多余的内存空间`。

如果余下的需要回收的空间很小，小于query_cache_min_res_unit，不能再次被使用，可能会造成内存碎片，影响查询性能。

### 面试官考点之缓存中的内存碎片无法避免，那么有什么办法优化吗？

没有什么办法能够完全避免内存碎片，但是选择合适的

> query_cache_min_res_unit

可以减少由碎片导致的内存空间浪费。

```
值太小，则浪费的空间更少，但是会导致频繁的内存块申请操作
```


```
如果设置得太大，那么碎片会很多
```

`调整合适的值其实是在平衡内存浪费和CPU消耗`

> 那么我如何确定这个平衡值？

可以通过内存实际消耗，计算单个查询的平均缓存大小

```
（query_cache_size - Qcache_free_memory）/ Qcache_queries_in_cahce
```

通过查看闲置内存块数量（Qcahce_free_blocks）来观察碎片。

> 如果产生的碎片过多，通过什么方法可以整理碎片？

```
通过FLUSH_QUERY_CAHCE清理碎片

这个命令将所有的查询缓存重新排序，

并将所有的空闲空间都聚焦到查询缓存的一块区域上。
```



### 面试官考点之MySQL4.0提出了查询缓存，它设计出来是为了加速哪些查询场景？

>1、并发性和查询QPS不高
>2、被访问的底层数据本质上是静态或半静态的
>3、查询密集型应用，更新频率非常低而只读查询频率非常高的场景

### 面试官考点之MySQL5.6中默认禁用，8.0以后完全移除，造成这个改变的原因是什么？

理想情况下，上述查询场景非常适合使用查询缓存，但是`实际的业务系统都是有CRUD操作`的。

在MySQL里QC是由一个全局锁在控制，每次更新QC的内存块都需要进行锁定，数据更新频繁，就会不断的失效缓存操作，同时缓存失效会造成大量的查询`缓存碎片化`，还会导致服务器的负载升高，影响数据库的稳定性。

所以MySQL官方经过抉择，果断移除了查询缓存模块。

### 面试官考点之生产环境要不要开启MySQL缓存？

建议不开启

```
根据MySQL官方的测试，如果对一个表执行简单的查询，

设置每次查询都不一样，

打开QC后，性能反而下降了13%左右
```

当然实际业务中，不会都是这种不同的请求，因此实际影响应该比这个小一些。

```
MySQL查询缓存的目的是为了提升查询性能，但它本身也是有性能开销的。
```

需要在合适的`业务场景下（读写压力模型）`使用

```
不合适的业务场景不但不能提升查询性能，查询缓存反而会变成MySQL的瓶颈。

对写密集型的应用场景来说，禁用缓存反而提高性能。
```



> 随缘更新，整理不易，欢迎联系小白讨论，大神巴巴请绕路！

> 更多精彩内容，欢迎关注微信公众号：**囧么肥事** (或搜索：jiongmefeishi)

